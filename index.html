<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <h1>chạy nhạc bnk</h1>
    
    <audio id="audioPlayer" controls></audio>
    
    <script>
        const bnkFileUrl = 'Holiday139.bnk'; 

        async function fetchAndPlayBnk() {
            try {
                const response = await fetch(bnkFileUrl);
                const bnkFileArrayBuffer = await response.arrayBuffer();
               
                const wemPcmData = extractWemPcmFromBnk(bnkFileArrayBuffer);

                if (wemPcmData) {
                    
                    const wavBlob = new Blob([wemPcmData], { type: 'audio/wav' });
                    const wavUrl = URL.createObjectURL(wavBlob);

                    const audioPlayer = document.getElementById('audioPlayer');
                    audioPlayer.src = wavUrl;
                    audioPlayer.play();
                    
                    audioPlayer.onended = () => URL.revokeObjectURL(wavUrl);
                } else {
                    alert('Không thể trích xuất dữ liệu WEM PCM từ tệp BNK.');
                }
            } catch (error) {
                alert('Lỗi khi tải hoặc xử lý tệp BNK: ' + error.message);
            }
        }
        
        function extractWemPcmFromBnk(arrayBuffer) {
            const dataView = new DataView(arrayBuffer);
            let offset = 0;

            while (offset < dataView.byteLength) {
                const chunkId = getString(dataView, offset, 4);
                const chunkSize = dataView.getUint32(offset + 4, true);

                if (chunkId === 'DATA') {
                    offset += 8; 
                    const wemPcmData = arrayBuffer.slice(offset, offset + chunkSize);
                    return decodeWemToWav(wemPcmData);  
                }
                offset += chunkSize + 8;
            }
            return null;
        }

        function decodeWemToWav(wemData) {
            
            const wavHeader = createWavHeader(wemData.byteLength, 44100, 2, 16);
            return concatenateArrayBuffers(wavHeader, wemData);
        }

        function createWavHeader(dataSize, sampleRate, channels, bitDepth) {
            const header = new ArrayBuffer(44);
            const view = new DataView(header);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true); 
            writeString(view, 8, 'WAVE');

            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); 
            view.setUint16(20, 1, true); 
            view.setUint16(22, channels, true); 
            view.setUint32(24, sampleRate, true); 
            view.setUint32(28, sampleRate * channels * (bitDepth / 8), true); 
            view.setUint16(32, channels * (bitDepth / 8), true); 
            view.setUint16(34, bitDepth, true); 

            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true); 

            return header;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function concatenateArrayBuffers(buffer1, buffer2) {
            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
            tmp.set(new Uint8Array(buffer1), 0);
            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
            return tmp.buffer;
        }

        function getString(dataView, offset, length) {
            let result = '';
            for (let i = 0; i < length; i++) {
                result += String.fromCharCode(dataView.getUint8(offset + i));
            }
            return result;
        }

        fetchAndPlayBnk();
    </script>
</body>
</html>